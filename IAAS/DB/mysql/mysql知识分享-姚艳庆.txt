mysql知识分享-姚艳庆

ST理想(40922358) 20:00:54
大家好！
我是姚艳庆，目前供职于盛大游戏
ST理想(40922358) 20:00:58
 很高兴今天能与大家一起分享关于MySQL相关知识

ST理想(40922358) 20:01:18
 主要从事MySQL、Oracle等数据库的支持与运维工作
对于数据库的相关发展及技术也较为关注，希望以后与大家多交流
分享中如有什么疑问可在分享后提出
ST理想(40922358) 20:01:34
 今天主要做关于MySQL与SSD性能方面的分析
ST理想(40922358) 20:01:54
 目前SSD已经在许多公司进行了使用，相信大家也有自己的使用心得
我今天的分享主要分为下面几个方面
ST理想(40922358) 20:02:18
 SSD特性
磁盘挂载
磁盘IO子系统
InnoDB体系结构
参数配置
多表并发在SSD上的性能
总结
ST理想(40922358) 20:03:10
 第一部分是关于SSD特性
ST理想(40922358) 20:03:34
SSD具有下面几个方面的优点
       闪存+主控+缓存+PCB+接口
       没有机械部件，数据读写都是电子讯号，不存在马达转速这样的瓶颈因素
       小文件随机性能较高
       SSD的随机读取延迟只有零点几毫秒，而7200RPM的随机读取延迟有7毫秒左右，5400RPM硬盘更是高达9毫秒之多
       支持掉电保护
ST理想(40922358) 20:04:15
ST理想(40922358) 20:04:27
这张图是Intel 3510的一些参数指标，可以看到随机读的性能可以达到7w+,800G写性能已经可以达到1.5w+
这是远超传统SAS盘的，对于IO密集型的数据库来说是跨越式的
ST理想(40922358) 20:05:02
 接下来是针对整个数据库系统应用的优化
ST理想(40922358) 20:05:32
首先就是在Raid卡的策略设置
对于Raid策略有WT、WB两种选择，具体如何选择需要根据SSD的性能来确认
如果多SSD组成个阵列，而Raid卡无法满足性能需要，则应采用WT，反之则还是选择传统的WB策略
对于单颗SSD来说，性能对比如下图
ST理想(40922358) 20:05:54
ST理想(40922358) 20:06:37
接下来是针对磁盘挂载
ST理想(40922358) 20:06:46
默认的情况下文件系统会在数据提交时强制底层设备刷新cache，避免数据丢失，称之为write barriers
ST理想(40922358) 20:07:14
由于通过文件系统进行刷新会有较多性能损耗
而数据库服务器底层存储设备基本都会采用具有掉电保护功能的RAID卡
ST理想(40922358) 20:07:37
固态硬盘也有自身的掉电保护机制，保证数据不会丢失
因此在这样的保护前提下是无需开启write barriers
ST理想(40922358) 20:08:07
 当文件被创建、修改和访问时，Linux系统会记录这些时间信息。
ST理想(40922358) 20:08:25
当系统的读文件操作频繁时，对于数据库这种多文件构成的系统来说会增加大量的IO操作
而这类信息对用户来说意义并不大，因此也应避免
ST理想(40922358) 20:09:03
因此在系统挂载时应配置 noatime,nobarries ，使磁盘性能能够发挥到最大
ST理想(40922358) 20:09:31
 下图为使用默认参数和使用 noatime,nobarries 所带来的性能差异对比
ST理想(40922358) 20:09:42
ST理想(40922358) 20:10:24
 可以看到性能提升达到了20%以上
ST理想(40922358) 20:10:56
以上是针对磁盘的优化
ST理想(40922358) 20:11:47
下面是关于磁盘IO子系统
ST理想(40922358) 20:12:03
在数据库系统中磁盘IO经常会成为系统的一个瓶颈 。
数据从磁盘读取到内存，在到CPU缓存和寄存器，然后进行处理，最后写回磁盘，
中间要经过很多的过程，下图是一个以write为例的 Linux 磁盘IO子系统的架构
ST理想(40922358) 20:12:20
ST理想(40922358) 20:13:36
这时候可以看到在 block 层有调度算法存在
ST理想(40922358) 20:13:49
 目前磁盘的调度算法有如下四种
 Anticipatory，CFQ，Deadline，NOOP
ST理想(40922358) 20:14:11
 1、Anticipatory:
      适用于个人PC，单磁盘系统；
2、CFQ(Complete Fair Queuing)：
      默认的IO调度算法，完全公平的排队调度算法
3、Deadline: 
      按照截止期限来循环在各个IO队列中进行调度
4、NOOP: 
      简单的FIFO队列进行调度
ST理想(40922358) 20:15:04
  由于SSD在对待顺序IO和随机IO没有什么区别。所以它不需要对临近的IO进行合并。避免了合并操作对CPU的使用。
  因此数据库采用SSD时，采用Noop是较为合理的
ST理想(40922358) 20:15:56
接下来就进入到了数据库层面
一起来看下InnoDB体系结构
ST理想(40922358) 20:16:05
运维-广州-坏人(849098) 20:16:14
 

系统消息(1000000) 20:16:37
Summer(849098) 被管理员禁言1小时
ST理想(40922358) 20:16:55
InnoDB由缓冲池、各个子功能线程、文件系统构成
其中缓冲池中Buffer Pool包含了  Page Cache 、Undo、Additional buffer pool 、log buffer 等
ST理想(40922358) 20:17:29
内存缓冲池
       对于数据库中页的修改操作，首先修改在缓冲池中的页， 然后再以一定的频率刷新到磁盘上。这就意味着不是每次缓冲池中的页修改时触发刷新回磁盘，而是通过checkpoint技术刷新回磁盘
       缓冲池的大小由 innodb_buffer_pool_size进行控制
ST理想(40922358) 20:17:49
允许多个缓冲池实例
       这样通过hash到不同缓冲池实例来减少锁的竞争
       由inodb_buffer_pool_instance进行控制
ST理想(40922358) 20:18:30
缓冲池是一个很大的内存区域，数据库通过LRU算法进行管理, 
LRU列表中加入的midpoint位置。新读取到的页，并不是直接放到lru列表的首部，而是midpoint位置。
默认情况下，在lru列表长度的5/8处
由innodb_old_blocks_pct控制
ST理想(40922358) 20:19:01
子功能线程包括
Master Thread
Purge Thread
PageCleaner Thread
ST理想(40922358) 20:19:23
Master Thread
       核心后台线程，主要负责将缓冲池的数据异步刷新到磁盘。例如脏页的刷新，插入缓冲的合并，undo 页的回收等
Purge Thread
       事务提交后。该事务相关的undolog可能不再需要。Purge Thread就是用来回收不需要的undo页的
PageCleaner Thread
       负责脏页的刷新操作。减轻master thread的工作以及对于用户查询线程的阻塞
ST理想(40922358) 20:19:57
文件系统包括
Undo 、Redo 、ibdata 、ib_log、*.ibd、各类日志等
ST理想(40922358) 20:21:10
在图中可以看到 Double Write 的模块 
这能带给 Innodb 存储引擎的是数据页的可靠性
ST理想(40922358) 20:21:31
避免partial page write
Double write由两部分组成:
内存中的 double write buffer
物理磁盘上的共享表空间中的连续128个页，大小和内存中（2M）一致
对缓冲池中的页进行刷新时，并不直接写磁盘，而是memcpy到 double write buffer. 之后通过 double write buffer 分两次，每次顺序写入共享表空间1M数据，然后马上调用fsync同步磁盘
由参数innodb_doublewrite进行控制
ST理想(40922358) 20:22:05
刷新邻近页功能
    当刷新一个脏页时，Innodb存储引擎会通过检测该页所在区的所有页，如果是脏页，会一起进行刷新
由参数innodb_flush_neighbors来进行控制
ST理想(40922358) 20:22:35
Check Point技术
    为了避免数据丢失的问题，事物数据库系统一般都采用了write ahead log策略。即事务提交时，先写重做日志，再修改页
ST理想(40922358) 20:22:53
由于数据修改先在缓冲池中进行，而由于缓冲池大小有限
那么当缓冲池刷新到磁盘时就需要CheckPoint技术来保证数据库的刷新
ST理想(40922358) 20:24:01
下面是针对参数的一些优化配置测试说明
由于各个系统状况的不同参数也需要适当调整，而非一成不变的配置
因此下面的配置只是在一个特定测试环境下结果，不是一个标准化的配置
ST理想(40922358) 20:24:50
innodb_io_capacity
这个参数据控制Innodb checkpoint时的IO能力
针对SSD需要根据线上的情况进行选择
下面是在单块SSD的情况下配置1000、4000两个值产生的性能差距
ST理想(40922358) 20:25:11
ST理想(40922358) 20:26:05
这里要注意
选用这两个值只是由于测试中1000与4000的值能较好的展现此值对于性能的影响
具体每个系统较优的值应根据实际情况进行配置
ST理想(40922358) 20:26:56
在数据库高写入压力的线上系统中innodb_log_file_size的大小也是会有一定影响的
过小的innodb_log_file_size容易在日志切换过程中发生性能下降的风险，造成线上波动
下图是对于日志大小的不同带来的性能差异
ST理想(40922358) 20:27:19
ST理想(40922358) 20:28:09
innodb_old_blocks_pct
缓存池可以被认为一条长LRU链表，该链表又分为2个子链表
一个子链表存放old pages(里面存放的是长时间未被访问的数据页)
另一个子链接存放new pages（里面存放的是最近被访问的数据页面）
如下图
ST理想(40922358) 20:28:24
 
ST理想(40922358) 20:29:16
当系统为Update为主的应用时，可以适当放大innodb_old_blocks_pct会获得较高的性能
将innodb_old_blocks_pct分别配置为5、90两个值获得如下结果
如下图
ST理想(40922358) 20:29:30
ST理想(40922358) 20:30:23
innodb_max_dirty_pages_pct
        通过 show engine innodb status \G来分析
        观察Modified pages 的较稳定值，通过调节innodb_max_dirty_pages_pct使Modified pages 保持在(buffer pool size)* innodb_max_dirty_pages_pct 以下
可以获得较好的性能
ST理想(40922358) 20:30:55
innodb_adaptive_flushing_lwm
    通过设置innodb_adaptive_flushing_lwm =0来关闭pre-flushing功能
ST理想(40922358) 20:31:39
innodb_lru_scan_depth 
        Innodb引擎有一个Page_cleaner线程用来扫描寻找dirty pages来进行flush 动作
        这个后台操作每秒执行一次，在普通的IO压力下可增加此参数的值，如果属于写压力较大的的系统，可适当减小次参数的值
ST理想(40922358) 20:32:27
innodb_purge_threads
      控制Purge Thread的数量，用来加快undo页的回收
      同时由于Purge Thread需要离散地读取undo页
      这样也能更进一步利用磁盘的随机读取性能

ST理想(40922358) 20:34:06
多表并发在SSD上的性能

针对SSD的随机写入与顺序写入
如果写入很小（就是说比簇大小要小），随机写入将比顺序写入慢。
如果写入是按簇大小对齐，随机写入将使用所有可用层级上的内部并行，并显示出和随机写入相同的性能

ST理想(40922358) 20:34:43
根据SSD的此项特性，应尽量将应用进行多表并发写入，而避免单表写入的瓶颈效应
测试结果如下图
ST理想(40922358) 20:35:13
 
ST理想(40922358) 20:36:07

很多并发的小写入请求将比单一的小写入请求提供更好的吞吐量
因此如果I/O比较小并不能整合到一起，最好是使用多线程。
单一的大写入请求和很多小并发写入请求相比，表现出相同的吞吐量，但会导致延迟。
单一的大写入比并发写入在响应时间上表现的更好
因此，只要可能，最好使用并发大写入
ST理想(40922358) 20:37:56
基于以上的原理及测试
更高效的SSD数据库性能应采取如下措施：

调整Raid可策略
       在SSD磁盘的读写性能低于Raid卡性能时，使用WB反之则需要采用WT策略
调整磁盘挂载参数
       nobarrier，noatime
调整系统 I/O调度算法
       采用不需要寻道的块设备如SSD的Noop算法

ST理想(40922358) 20:39:32
调整参数
使数据库参数配置可根据线上压力调节以下参数获得较好性能:
        innodb_flush_log_at_trx_commit
        innodb_io_capacity
        innodb_max_dirty_pages_pct
        innodb_log_file_size
        innodb_old_blocks_pct
        innodb_adaptive_flushing_lwm
ST理想(40922358) 20:39:46
对数据库采用多表并发写，能够提升数据库的写入性能
ST理想(40922358) 20:40:24
谢谢大家
我的分享就到此








